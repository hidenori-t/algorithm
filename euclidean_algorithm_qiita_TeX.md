### "ユークリッドの互除法" について
<!-- ブルーバックス量子コンピュータについて&「アルゴリズム」のキホンを参考にした -->
***
Euclidean Algorithm とは,最大公約数を効率的に求める方法.
紀元前300年ごろの「ユークリッド原論」に記されていて,最古のアルゴリズムといわれている.
2つの数の最大公約数は高速に計算が可能
互除法とは,お互いに割り算をしていく,という意味

定理
「整数$X$と$Y$ ($X\geqq Y$)を与えたとき,$X$の$Y$による剰余を$R$とすると,$X$と$Y$の最大公約数は,$Y$と$R$の最大公約数と等しい.ただし,$X$と$0$との最大公約数は$X$とする」

Algorithm
***
1. 変数RにXのYによる剰余を代入 X=R (mod Y)
2. 変数Rが0でない間,以下の手順3~5をくり返す R=¬0
3. 変数Xに変数Yの値を代入する X=Y
4. 変数Yに変数Rの値を代入する Y=R
5. 変数RにXのYによる剰余を代入 X=R (mod Y)
6. 変数最大公約数GCDに変数Yの値を代入

$208$ と $117$ の最大公約数を求めるとする.
1. 208 = 91 (mod 117), R=91
2. 変数Rが0でない間,上記の手順3~5をくり返す
3. X=117
4. Y=91
5. 117 = 26 (mod 91), R=26
6. X=91
4. Y=26
5. 91 = 13 (mod 26), R=13
6. X=26
4. Y=13
5. 26 = 0 (mod 13), R=0
6. GCD = 13

<!--
1. 小さい方の数で大きい方の数を割り,「あまり」を求める.
$X$の$Y$による剰余を$R$とする X=R (mod Y)
(変数RにX÷Yのあまりを代入と同じ)

2. 今求めた「あまり」で, 先ほど割るのに使った数を割り,「あまり」を求める.
$Y$の今求めた変数$R$による剰余を$R$とする Y=R (mod R)

3. 2を「あまり」が $0$ になるまでくり返す.
2を変数Rが$0$ になるまでloop
2. 変数Rが0でない間,以下の手順3~5をくり返す ということは,2と3~5は同じ??

4. 最後に求めた「あまり」が,最大公約数である.
最後に求めた変数R(R=¬0 Y=R)がGCDである.
変数GCDに変数Y(最後に求めた変数R)の値を代入
-->

<!--
1. 小さい方の数で大きい方の数を割り,「あまり」を求める.
2. 今求めた「あまり」で, 先ほど割るのに使った数を割り,「あまり」を求める.
3. 2を「あまり」が $0$ になるまでくり返す.
4. 最後に求めた「あまり」が,最大公約数である.
-->

$208$ と $117$ の最大公約数を求めるとする.
***
$208 = 91 \begin{eqnarray}\pmod{117}\end{eqnarray}$

208 = 91 (mod 117)
117 = 26 (mod 91)
91 = 13 (mod 26)
26 = 0 (mod13)
よって,最大公約数は 13

ミソ
1. 割り算をして求まった「あまり 変数R」は,「割られる数 X」の半分より必ず小さい. R<X/2
91<208/2 26>117/2 13<91/2 0>26/2
1. 「割られる数 X」は2つ前の割り算の「あまり 変数R」の半分より必ず小さくなる. X<2つ前のR/2
26<91/2
よって,手順2を繰り返すごとに「あまり」は急速に(指数関数的に)小さくなっていき,最大公約数を非常に高速に特定することができる.

***
# 『難しそうなプログラミングをやさしく教えてくれる本』p.185 リスト1 ユークリッドの互除法を利用して最大公約数(Greatest Common Divisor, gcd)を計算する


```python
def gcd(a, b):
    # return a if b == 0 else gcd(b, a % b)

    if b == 0:
        return a
    else:
        return gcd(b, a % b)

print(gcd(342, 162))
```